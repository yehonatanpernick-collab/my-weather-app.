<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ultra Boxing Sim V2.0</title>
    <style>
        body {
            margin: 0;
            background: #050505;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            box-shadow: 0 0 100px rgba(0,0,0,0.9);
            border-top: 5px solid #333;
            border-bottom: 5px solid #333;
            background: linear-gradient(to bottom, #1a1a1a 0%, #000 100%);
        }
        #ui {
            position: absolute;
            top: 20px;
            width: 900px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            text-transform: uppercase;
            font-weight: 900;
            letter-spacing: 2px;
        }
        .fighter-hud { width: 40%; position: relative; }
        .bar-bg { height: 25px; background: #333; transform: skewX(-20deg); border: 2px solid #555; overflow: hidden; }
        .hp-bar { height: 100%; width: 100%; background: #e74c3c; transition: width 0.1s linear; box-shadow: 0 0 15px #e74c3c; }
        .stamina-bg { height: 10px; width: 80%; background: #222; margin-top: 5px; transform: skewX(-20deg); border: 1px solid #444; }
        .st-bar { height: 100%; width: 100%; background: #f1c40f; transition: width 0.1s; }
        .name { font-size: 30px; margin-bottom: 5px; text-shadow: 2px 2px 0 #000; font-style: italic; }
        
        #overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        #big-text {
            font-size: 100px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 30px rgba(255,255,255,0.8);
            transform: scale(0);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .controls {
            position: absolute;
            bottom: 10px;
            color: #666;
            font-size: 12px;
            text-align: center;
            width: 100%;
        }
        .key { display: inline-block; padding: 2px 6px; border: 1px solid #666; border-radius: 4px; color: #aaa; }
    </style>
</head>
<body>

<div id="ui">
    <div class="fighter-hud">
        <div class="name" style="color:#3498db">PLAYER 1</div>
        <div class="bar-bg"><div id="hp1" class="hp-bar"></div></div>
        <div class="stamina-bg"><div id="st1" class="st-bar"></div></div>
    </div>
    <div class="fighter-hud" style="text-align:right">
        <div class="name" style="color:#e74c3c">CPU CHAMP</div>
        <div class="bar-bg"><div id="hp2" class="hp-bar" style="float:right"></div></div>
        <div style="clear:both"></div>
        <div class="stamina-bg" style="float:right"><div id="st2" class="st-bar" style="float:right"></div></div>
    </div>
</div>

<div id="overlay"><div id="big-text">KO!</div></div>
<canvas id="game" width="900" height="500"></canvas>
<div class="controls">
    זוז: <span class="key">Arrows</span> | מכה: <span class="key">Z</span> | מכה חזקה: <span class="key">C</span> | הגנה: <span class="key">X</span> | אתחול: <span class="key">R</span>
</div>

<script>
/**
 * ULTRA BOXING ENGINE V2
 * Includes: Particle System, Screen Shake, Procedural Animation, Dynamic AI
 */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- הגדרות מנוע ---
const GRAVITY = 0;
const GROUND_Y = 380;
let timeScale = 1.0; // לשליטה בהילוך איטי
let shakeIntensity = 0;

// --- חלקיקים ואפקטים ---
let particles = [];
let floatingTexts = [];

class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.life = 1.0;
        this.color = color;
        this.size = Math.random() * 4 + 2;
    }
    update() {
        this.x += this.vx * timeScale;
        this.y += this.vy * timeScale;
        this.vy += 0.2 * timeScale; // כוח משיכה לחלקיקים
        this.life -= 0.03 * timeScale;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 1.0;
        this.vy = -2;
    }
    update() {
        this.y += this.vy * timeScale;
        this.life -= 0.02 * timeScale;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.font = "bold 24px Arial";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

function spawnParticles(x, y, count, color) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color, 10));
    }
}

function spawnText(x, y, text, color) {
    floatingTexts.push(new FloatingText(x, y, text, color));
}

// --- מחלקת לוחם ---
class Fighter {
    constructor(x, isAI, color) {
        this.x = x;
        this.y = GROUND_Y;
        this.vx = 0;
        this.width = 40;
        this.height = 100;
        this.color = color;
        this.isAI = isAI;
        this.facing = isAI ? -1 : 1;
        
        // Stats
        this.hp = 100;
        this.maxHp = 100;
        this.stamina = 100;
        
        // State
        this.state = 'idle'; // idle, move, attack, block, hit, ko
        this.frame = 0;
        this.punchType = 'none'; // light, heavy
        this.blockTimer = 0;
        
        // Animation Vars
        this.animOffset = 0;
        this.gloveExtension = 0;
    }

    update(target) {
        if (this.state === 'ko') return;

        // Stamina Regen
        if (this.state === 'idle' || this.state === 'move') {
            if (this.stamina < 100) this.stamina += 0.4 * timeScale;
        }

        // Physics & Movement
        this.x += this.vx * timeScale;
        
        // Friction
        this.vx *= 0.8;

        // Breathe Animation
        this.animOffset += 0.1 * timeScale;
        
        // Boundaries
        if (this.x < 20) this.x = 20;
        if (this.x > 880) this.x = 880;

        // Cooldowns
        if (this.frame > 0) this.frame -= 1 * timeScale;
        else if (this.state === 'attack' || this.state === 'hit') {
            this.state = 'idle';
            this.gloveExtension = 0;
        }

        if (this.isAI) this.aiLogic(target);
    }

    aiLogic(target) {
        const dist = Math.abs(this.x - target.x);
        const range = 90;

        // Always face target
        this.facing = (target.x > this.x) ? 1 : -1;

        if (this.state === 'hit' || this.state === 'attack') return;

        // React to player attack
        if (target.state === 'attack' && dist < 120 && Math.random() < 0.05) {
            this.state = 'block';
            this.frame = 20;
            return;
        }

        // Release block
        if (this.state === 'block' && target.state !== 'attack') {
            this.state = 'idle';
        }

        // Offensive
        if (dist < range) {
            if (this.stamina > 20 && Math.random() < 0.08) {
                this.attack(target, Math.random() > 0.7 ? 'heavy' : 'light');
            } else if (this.stamina < 30) {
                 // Retreat
                 this.vx = -3 * this.facing;
                 this.state = 'move';
            }
        } else {
            // Approach
            this.vx = 2.5 * this.facing;
            this.state = 'move';
        }
    }

    attack(target, type) {
        if (this.state !== 'idle' && this.state !== 'move') return;
        
        let cost = (type === 'heavy') ? 35 : 15;
        if (this.stamina < cost) return;

        this.stamina -= cost;
        this.state = 'attack';
        this.punchType = type;
        this.frame = (type === 'heavy') ? 25 : 15;
        
        // Sound & Visuals handled in draw mainly, logic here:
        // Hit check delayed slightly for "impact" feel
        setTimeout(() => {
            if (this.state !== 'attack') return; // Interrupted
            this.checkHit(target, type);
        }, (type === 'heavy' ? 200 : 100) / timeScale); // Scale timeout logic roughly
    }

    checkHit(target, type) {
        const reach = (type === 'heavy') ? 100 : 70;
        const dist = Math.abs(this.x - target.x);
        
        // Hitbox logic
        if (dist < reach && (this.facing === 1 && target.x > this.x || this.facing === -1 && target.x < this.x)) {
            
            let damage = (type === 'heavy') ? 25 : 8;
            let blocked = false;

            if (target.state === 'block') {
                blocked = true;
                damage *= 0.1;
                target.stamina -= 10;
                spawnParticles(target.x, target.y - 60, 5, "#fff"); // Sparks
                spawnText(target.x, target.y - 120, "BLOCKED", "#aaa");
            } else {
                spawnParticles(target.x, target.y - 80, 15, "#e74c3c"); // Blood/Sweat
                spawnText(target.x, target.y - 120, Math.floor(damage), "#ff0000");
                
                // IMPACT
                shakeIntensity = (type === 'heavy') ? 15 : 5;
                target.takeDamage(damage, this.facing, type);
            }
        }
    }

    takeDamage(amount, hitterDir, type) {
        this.hp -= amount;
        this.state = 'hit';
        this.frame = 15;
        this.vx = hitterDir * (type === 'heavy' ? 10 : 5); // Knockback
        
        if (this.hp <= 0) {
            this.hp = 0;
            this.state = 'ko';
            startSlowMo();
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Breathe Bobbing
        let bob = Math.sin(this.animOffset) * 2;
        if (this.state === 'ko') bob = 50; // Lying down offset

        // Rotation for KO
        if (this.state === 'ko') {
            ctx.rotate(this.facing * Math.PI / 2);
            ctx.translate(0, -20);
        }

        // Color Setup
        const skinColor = "#ffdbac";
        const gloveColor = "#c0392b";
        const shortsColor = this.color;

        // --- DRAW BODY PROCEDURALLY ---
        
        // Legs
        ctx.fillStyle = "#222";
        ctx.fillRect(-15, -40 + bob, 10, 40); // Back Leg
        ctx.fillRect(5, -40 + bob, 10, 40);  // Front Leg

        // Torso
        ctx.fillStyle = skinColor;
        ctx.fillRect(-15, -90 + bob, 30, 50);
        
        // Shorts
        ctx.fillStyle = shortsColor;
        ctx.fillRect(-16, -55 + bob, 32, 20);

        // Head
        ctx.fillStyle = skinColor;
        ctx.beginPath();
        ctx.arc(0, -100 + bob, 12, 0, Math.PI*2);
        ctx.fill();

        // Arms Logic
        let armX = 15 * this.facing;
        let armY = -85 + bob;
        
        // Attack Animation Calculation
        let extend = 0;
        if (this.state === 'attack') {
            // Simple ease-out for punch
            const maxFrame = (this.punchType === 'heavy') ? 25 : 15;
            const progress = 1 - (this.frame / maxFrame);
            if (progress < 0.5) extend = progress * 80;
            else extend = (1 - progress) * 80;
        }

        // Block Position
        if (this.state === 'block') {
            armX = 10 * this.facing;
            armY = -95 + bob;
        }

        // Back Arm
        ctx.fillStyle = skinColor;
        ctx.fillRect(-10, -90 + bob, 10, 30);
        ctx.fillStyle = gloveColor;
        ctx.beginPath();
        ctx.arc(-5 + (this.facing * 5), -75 + bob, 12, 0, Math.PI*2);
        ctx.fill();

        // Front Arm (Punching Arm)
        ctx.fillStyle = skinColor;
        // Shoulder
        ctx.beginPath();
        ctx.arc(0, -90 + bob, 8, 0, Math.PI*2);
        ctx.fill();
        
        // Glove
        ctx.fillStyle = gloveColor;
        let gloveX = (this.facing * 20) + (this.facing * extend);
        let gloveY = -80 + bob;
        
        if (this.state === 'block') {
            gloveX = this.facing * 15;
            gloveY = -105 + bob;
        }

        ctx.beginPath();
        ctx.arc(gloveX, gloveY, 14, 0, Math.PI*2);
        ctx.fill();
        // Glove shine
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.beginPath();
        ctx.arc(gloveX - 2, gloveY - 2, 5, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

// --- משתני משחק גלובליים ---
const p1 = new Fighter(200, false, "#3498db");
const p2 = new Fighter(700, true, "#e74c3c");
let keys = {};
let gameOver = false;

// --- שליטה ---
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyZ') p1.attack(p2, 'light');
    if (e.code === 'KeyC') p1.attack(p2, 'heavy');
    if (e.code === 'KeyX') p1.state = 'block';
    if (e.code === 'KeyR' && gameOver) location.reload();
});

window.addEventListener('keyup', e => {
    keys[e.code] = false;
    if (e.code === 'KeyX' && p1.state === 'block') p1.state = 'idle';
});

function startSlowMo() {
    timeScale = 0.2;
    gameOver = true;
    const txt = document.getElementById('big-text');
    txt.style.transform = "scale(1)";
    if (p1.hp > 0) {
        txt.innerText = "YOU WIN!";
        txt.style.color = "#2ecc71";
    } else {
        txt.innerText = "KNOCKOUT";
        txt.style.color = "#e74c3c";
    }
}

// --- לולאת המשחק ---
function loop() {
    // Screen Shake Logic
    let shakeX = 0, shakeY = 0;
    if (shakeIntensity > 0) {
        shakeX = (Math.random() - 0.5) * shakeIntensity;
        shakeY = (Math.random() - 0.5) * shakeIntensity;
        shakeIntensity *= 0.9;
        if (shakeIntensity < 0.5) shakeIntensity = 0;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY);
    ctx.clearRect(-10, -10, canvas.width+20, canvas.height+20);

    // Floor
    ctx.fillStyle = "#111";
    ctx.fillRect(0, GROUND_Y, canvas.width, 120);
    // Ring Ropes
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(0, GROUND_Y - 50); ctx.lineTo(canvas.width, GROUND_Y - 50);
    ctx.moveTo(0, GROUND_Y - 100); ctx.lineTo(canvas.width, GROUND_Y - 100);
    ctx.stroke();

    // Logic
    if (!gameOver || timeScale < 1.0) { // Keep updating slowmo
        if (keys['ArrowLeft']) p1.vx = -4;
        if (keys['ArrowRight']) p1.vx = 4;
        
        p1.update(p2);
        p2.update(p1);
    }

    // Drawing
    // Shadow
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.beginPath();
    ctx.ellipse(p1.x, GROUND_Y + 5, 20, 5, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(p2.x, GROUND_Y + 5, 20, 5, 0, 0, Math.PI*2);
    ctx.fill();

    p1.draw(ctx);
    p2.draw(ctx);

    // Particles
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].update();
        particles[i].draw(ctx);
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    // Floating Text
    for(let i=floatingTexts.length-1; i>=0; i--) {
        floatingTexts[i].update();
        floatingTexts[i].draw(ctx);
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
    }

    ctx.restore();

    // UI Updates
    document.getElementById('hp1').style.width = p1.hp + '%';
    document.getElementById('st1').style.width = p1.stamina + '%';
    document.getElementById('hp2').style.width = p2.hp + '%';
    document.getElementById('st2').style.width = p2.stamina + '%';

    requestAnimationFrame(loop);
}

loop();

</script>
</body>
</html>
